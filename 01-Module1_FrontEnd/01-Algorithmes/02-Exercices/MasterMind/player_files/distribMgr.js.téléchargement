distribMgr = {
	projectId : null
};

distribMgr.buildSkeleton = function(pProjectId) {
	var vSession = distribEngine.getSession();
	var vProjects = vSession.projects;
	var vParticipants = vSession.participants;
	var vRooms = vSession.rooms;
	var vActors = vSession.actors;

	var vProjectId;
	for (vProjectId in vProjects) {
		if (vProjects[vProjectId].comps[0].depotPath == distribEngine
				.findMainDepotPath())
			break;
	}

	this.projectId = pProjectId || vProjectId;

	this.project = Object.assign({}, vProjects[this.projectId]);

	this.project.participants = {};
	for (var vParticipantId in vParticipants) {
		var vParticipant = vParticipants[vParticipantId];
		if (vParticipant.projectId == this.projectId)
			this.project.participants[vParticipantId] = Object.assign({},
					vParticipant);
	}

	this.project.rooms = {};
	for (var vRoomId in vRooms) {
		var vRoom = vRooms[vRoomId];
		if (vRoom.projectId == this.projectId) {
			var vRoomCopy = Object.assign({}, vRoom);
			vRoomCopy.actors = {};
			for (var vActorId in vActors) {
				var vActor = vActors[vActorId];
				if (vActor.roomId == vRoomId) {
					vRoomCopy.actors[vActorId] = Object.assign({}, vActor);
				}
			}
			this.project.rooms[vRoomId] = vRoomCopy;
		}
	}
}

distribMgr.getParticipantId = function(pForceFromSelectIfTeacher) {
	// si plusieurs participants sur le depotPath courant, on choisit le premier
	// de type enseignant, le premier tout court sinon
	for (var vParticipantId in distribMgr.project.participants) {
		var vParticipant = distribMgr.project.participants[vParticipantId];
		if (vParticipant.kind == "T")
			// TODO : IHM de s√©lection d'un stagiaire
			return pForceFromSelectIfTeacher ? distribMgr.fSelectedLearnerId : vParticipantId;
	}
	return Object.keys(distribMgr.project.participants)[0];
}

distribMgr.getActorId = function(pRoomCode) {
	for (var vRoomId in distribMgr.project.rooms) {
		var vRoom = distribMgr.project.rooms[vRoomId];
		// on renvoit le premier actor pour cette room
		// TODO : checker si cet actor est bien "active"
		if (vRoom.code == pRoomCode)
			return Object.keys(vRoom.actors)[0];
	}
	return null;
}

distribMgr.getRoomId = function(pRoomCode) {
	for (var vRoomId in distribMgr.project.rooms) {
		var vRoom = distribMgr.project.rooms[vRoomId];
		if (vRoom.code == pRoomCode)
			return vRoomId;
	}
	return null;
}

distribMgr.addRoomToSkeleton = function(pRoomId, pRoom) {
	distribMgr.project.rooms[pRoomId] = pRoom;
}


distribMgr.findLastOpenedPage = function() {
	try {
		var vParticipantId = distribMgr.getParticipantId();
	} catch(e) {
		console.error(e);
	}
	if(vParticipantId) {
		distribEngine.sendParticipantMsgs(vParticipantId, {type:"lastOpened_recordsGet",anchor:distribEngine.findMainDepotPath(),fetchChildren:false});
	}
}

if (typeof Object.assign != 'function') {
	Object.assign = function(target, varArgs) { // .length of function is 2
		'use strict';
		if (target == null) { // TypeError if undefined or null
			throw new TypeError('Cannot convert undefined or null to object');
		}

		var to = Object(target);

		for (var index = 1; index < arguments.length; index++) {
			var nextSource = arguments[index];

			if (nextSource != null) { // Skip over if undefined or null
				for (var nextKey in nextSource) {
					// Avoid bugs when hasOwnProperty is shadowed
					if (Object.prototype.hasOwnProperty.call(nextSource,
							nextKey)) {
						to[nextKey] = nextSource[nextKey];
					}
				}
			}
		}
		return to;
	};
}